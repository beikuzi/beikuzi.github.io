<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>acm | 北枯紫的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="(深度：1)网站收录 暂时分为三个模块：网站，纯题目+简析，详细代码   [oi-wiki](https:&#x2F;&#x2F;oi-wiki.org&#x2F;)   O(n)         10^8   O(nlogn)      10^6   O(n√n)         10^5   O(n2)          5000   O(n^3)         300   O(2^n)      25   O(n">
<meta property="og:type" content="article">
<meta property="og:title" content="acm">
<meta property="og:url" content="http://example.com/2333/05/20/utf8-ansi-acm/index.html">
<meta property="og:site_name" content="北枯紫的博客">
<meta property="og:description" content="(深度：1)网站收录 暂时分为三个模块：网站，纯题目+简析，详细代码   [oi-wiki](https:&#x2F;&#x2F;oi-wiki.org&#x2F;)   O(n)         10^8   O(nlogn)      10^6   O(n√n)         10^5   O(n2)          5000   O(n^3)         300   O(2^n)      25   O(n">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2333-05-19T17:10:31.000Z">
<meta property="article:modified_time" content="2021-03-29T01:53:27.231Z">
<meta property="article:author" content="beikuzi">
<meta property="article:tag" content="acm">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="北枯紫的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">北枯紫的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-utf8-ansi-acm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2333/05/20/utf8-ansi-acm/" class="article-date">
  <time class="dt-published" datetime="2333-05-19T17:10:31.000Z" itemprop="datePublished">2333-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      acm
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <details>

<details>
<summary>(深度：1)网站收录</summary>
暂时分为三个模块：网站，纯题目+简析，详细代码  
[oi-wiki](https://oi-wiki.org/)  
O(n)         10^8  
O(nlogn)      10^6  
O(n√n)         10^5  
O(n2)          5000  
O(n^3)         300  
O(2^n)      25  
O(n!)          11  

<p><a target="_blank" rel="noopener" href="https://paste.ubuntu.com/">代码展示</a><br><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_precedence">运算符优先度</a><br><a target="_blank" rel="noopener" href="http://acm.scau.net.cn:8000/uoj/login.jsp">scau8000服务器</a><br><a target="_blank" rel="noopener" href="http://acm.scau.edu.cn:8000/uoj/login.jsp">scau8000服务器2</a>  </p>
<p>大佬博客<br><a target="_blank" rel="noopener" href="https://along7587.github.io/">七爷-永康</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40732657">晁棠巨佬(唐朝)</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ECJTUACM-873284962/articles/9198885.html">美观，int128</a><br><a target="_blank" rel="noopener" href="http://jiruyi910387714.is-programmer.com/">很多算法，python</a>  </p>
<p>刷题列表（已完成<br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419164#problem/A">scau寒假</a>  </p>
<p>刷题列表(限时)<br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/280030">scau-dp2</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419166">scau-dp</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419165">scau-图</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/419167">scau-数据结构</a><br><a target="_blank" rel="noopener" href="https://vjudge.net/contest/421255">scau-后缀自动机</a>  </p>
<p>刷题列表<br>//209074233fal<br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/">luogu</a><br>//<br>[acwing]<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/">https://www.acwing.com/problem/</a><br><a target="_blank" rel="noopener" href="https://codeforces.ml/">codeforce</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/">蓝桥杯</a><br><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/home">牛客</a>  </p>
<p>刷题文件<br>数据结构<br>群，牛客赛标称<br>蓝桥杯真题  </p>
<p>打不开的（需要vpn<br>light-oj  </p>
</details>

<details>
<summary>(深度：1)题目简析</summary>

<details>
<summary>(深度：2)dp</summary>

<details>
<summary>(深度：3)背包</summary>

<details>
<summary>(深度：4)代码</summary>

<details>
<summary>(深度：5)1-01背包</summary>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</span><br><span class="line"></span><br><span class="line">第 i 件物品的体积是 vi，价值是 wi。</span><br><span class="line"></span><br><span class="line">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</span><br><span class="line"></span><br><span class="line">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm&#x3D;1010;</span><br><span class="line">int arr[maxm];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int v,w;</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;v,&amp;w);</span><br><span class="line">		for(int j&#x3D;m;j&gt;&#x3D;v;j--)arr[j]&#x3D;max(arr[j],arr[j-v]+w);</span><br><span class="line">	&#125;printf(&quot;%d&quot;,arr[m]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>(深度：5)2-完全背包</summary>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</span><br><span class="line"></span><br><span class="line">第 i 种物品的体积是 vi，价值是 wi。</span><br><span class="line"></span><br><span class="line">求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line"></span><br><span class="line">接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line">*&#x2F; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm&#x3D;1010;</span><br><span class="line">int arr[maxm];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	int v,w;</span><br><span class="line">    	scanf(&quot;%d%d&quot;,&amp;v,&amp;w);</span><br><span class="line">    	for(int j&#x3D;v;j&lt;&#x3D;m;j++)arr[j]&#x3D;max(arr[j],arr[j-v]+w);</span><br><span class="line">    &#125;printf(&quot;%d&quot;,arr[m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>(深度：5)3-多重背包</summary>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有 N 种物品和一个容量是 V 的背包。</span><br><span class="line"></span><br><span class="line">第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</span><br><span class="line"></span><br><span class="line">求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line"></span><br><span class="line">接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxm&#x3D;1010;</span><br><span class="line">int arr[maxm];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	int v,w,cnt;</span><br><span class="line">    	scanf(&quot;%d%d%d&quot;,&amp;v,&amp;w,&amp;cnt);</span><br><span class="line">    	while(cnt--)for(int j&#x3D;m;j&gt;&#x3D;v;j--)arr[j]&#x3D;max(arr[j],arr[j-v]+w);</span><br><span class="line">    &#125;printf(&quot;%d&quot;,arr[m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>(深度：5)4-二进制优化多重背包</summary>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有 N 种物品和一个容量是 V 的背包。</span><br><span class="line"></span><br><span class="line">第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</span><br><span class="line"></span><br><span class="line">求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line"></span><br><span class="line">接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">0&lt;N≤1000</span><br><span class="line">0&lt;V≤2000</span><br><span class="line">0&lt;vi,wi,si≤2000</span><br><span class="line">*&#x2F; </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;原理：保证拆出各个位二进制为1，如1，2，4，8，16，因为里面的所有数从0~31都可以被组合出来 </span><br><span class="line">&#x2F;&#x2F;m为2000 </span><br><span class="line">const int maxm&#x3D;2020;</span><br><span class="line">int arr[maxm];</span><br><span class="line">#define M(x,y) make_pair(x,y)</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">queue&lt;pii&gt; q;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	int v,w,cnt;</span><br><span class="line">    	scanf(&quot;%d%d%d&quot;,&amp;v,&amp;w,&amp;cnt);</span><br><span class="line">    	for(int k&#x3D;1;k&lt;&#x3D;cnt;k*&#x3D;2)</span><br><span class="line">    	&#123;</span><br><span class="line">    		cnt-&#x3D;k;</span><br><span class="line">    		q.push(M(k*v,k*w));</span><br><span class="line">    	&#125;if(cnt&gt;0)q.push(M(cnt*v,cnt*w));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while(!q.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">    	int v&#x3D;q.front().first,w&#x3D;q.front().second;</span><br><span class="line">    	q.pop();</span><br><span class="line">    	for(int j&#x3D;m;j&gt;&#x3D;v;j--)arr[j]&#x3D;max(arr[j],arr[j-v]+w);</span><br><span class="line">    &#125;printf(&quot;%d&quot;,arr[m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>(深度：5)5-单调队列</summary>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有一个长为 n 的序列 a，以及一个大小为 k 的窗口。现在这个从左边开始向右滑动</span><br><span class="line">每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">The array is [1,3,-1,-3,5,3,6,7][1,3,?1,?3,5,3,6,7], and k &#x3D; 3k&#x3D;3</span><br><span class="line"></span><br><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br><span class="line"></span><br><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define M(x,y) make_pair(x,y)</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">deque&lt;pii&gt;q_min,q_max;&#x2F;&#x2F;qmin前小后大，qmax前大后小 </span><br><span class="line">void test(deque&lt;pii&gt; p)</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;p.size() ;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;p.front() .first&lt;&lt;&#39; &#39;&lt;&lt;p.front().second&lt;&lt;endl;</span><br><span class="line">		p.push_back(p.front() );</span><br><span class="line">		p.pop_front(); </span><br><span class="line">	&#125;cout&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line">const int maxn&#x3D;1010101;</span><br><span class="line">int ans[2][maxn];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    </span><br><span class="line">    q_min.push_back(M(t,1));</span><br><span class="line">   	q_max.push_back(M(t,1));</span><br><span class="line">    ans[0][1]&#x3D;t;ans[1][1]&#x3D;t;</span><br><span class="line">    </span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    	</span><br><span class="line">    	while(q_min.back().first&gt;t)&#x2F;&#x2F;保证单调性 </span><br><span class="line">    	&#123;&#x2F;&#x2F;建立单调队列 </span><br><span class="line">    		q_min.pop_back();&#x2F;&#x2F;去掉最后不合格的 </span><br><span class="line">    		if(q_min.empty() )break;</span><br><span class="line">    	&#125;q_min.push_back(M(t,i));&#x2F;&#x2F;推入 </span><br><span class="line">    	</span><br><span class="line">    	while(q_max.back().first&lt;t)</span><br><span class="line">    	&#123;</span><br><span class="line">    		q_max.pop_back();</span><br><span class="line">    		if(q_max.empty() )break;</span><br><span class="line">    	&#125;q_max.push_back(M(t,i));</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    	while(1)</span><br><span class="line">    	&#123;&#x2F;&#x2F;输出队头，如果他的编号满足和当前位置差是m-1 </span><br><span class="line">    		if(q_min.front().second&gt;&#x3D;i-m+1)break;&#x2F;&#x2F;保证在m以内 5的3的话只能 345</span><br><span class="line">    		q_min.pop_front();</span><br><span class="line">    	&#125;ans[0][i]&#x3D;q_min.front().first ;</span><br><span class="line">    	</span><br><span class="line">    	while(1)</span><br><span class="line">    	&#123;</span><br><span class="line">    		if(q_max.front().second&gt;&#x3D;i-m+1)break;</span><br><span class="line">    		q_max.pop_front();</span><br><span class="line">    	&#125;ans[1][i]&#x3D;q_max.front().first;</span><br><span class="line">    	</span><br><span class="line">    	&#x2F;&#x2F;test(q_min);test(q_max);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;m;i&lt;&#x3D;n;i++)printf(&quot;%d &quot;,ans[0][i]);printf(&quot;\n&quot;);</span><br><span class="line">    for(int i&#x3D;m;i&lt;&#x3D;n;i++)printf(&quot;%d &quot;,ans[1][i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>(深度：5)6-单调队列背包</summary>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">有 N 种物品和一个容量是 V 的背包。</span><br><span class="line"></span><br><span class="line">第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</span><br><span class="line"></span><br><span class="line">求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</span><br><span class="line">输出最大价值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V (0&lt;N≤1000, 0&lt;V≤20000)，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line"></span><br><span class="line">接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">0&lt;N≤1000</span><br><span class="line">0&lt;V≤20000</span><br><span class="line">0&lt;vi,wi,si≤20000</span><br><span class="line">*&#x2F;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn&#x3D;20202;</span><br><span class="line">int q[maxn];</span><br><span class="line">int f[maxn],g[maxn];</span><br><span class="line"></span><br><span class="line">&#x2F;*1.队列是干嘛用的 </span><br><span class="line">队头储存最大价值所需要的已选背包需求量</span><br><span class="line">维护的单调队列保证能取队头的背包需求量q[head]时，得到的总价值f[q[head]]是最大的值 </span><br><span class="line">每一轮队列都会被清空，队列只有1+m,1+2m,1+3m……有效，意义是由 前面的方案决定</span><br><span class="line">之前选择的每一个情况，都可以决定你现在怎么选</span><br><span class="line">你只需要在乎从队列中选第一个能用的最佳情况，然后选择填满这个物品，或者放弃这个物品，保持状态</span><br><span class="line">每个g最多只变一次 </span><br><span class="line">用队列的只有上一轮状态f会用，当前状态g不会用队列</span><br><span class="line">是之前状态的最值+当前状态选j个的结果，所以要求j要够数</span><br><span class="line">*&#x2F; </span><br><span class="line"></span><br><span class="line">&#x2F;*2.k是什么 </span><br><span class="line">k是背包容量i-w*j		max[i]&#x3D;max[i-w*j]+v*j; </span><br><span class="line">k-q[l]&gt;(w*All_cnt)	这个k容量的背包-队头的最大背包已选需求量 ,是当前物品应选质量w*j，除以w就是选择个数j</span><br><span class="line">k+&#x3D;w是下一个因为填这种物品能被影响的背包 </span><br><span class="line">如果当前物品应选质量比能选质量还要多，那么不行 ，l++原因： </span><br><span class="line">当前最多可以填五个物品时，第一个填物品的方案需要用6个，不能选择，那么后面背包空间更大时，第一个方案更不能选 </span><br><span class="line">*&#x2F; </span><br><span class="line"></span><br><span class="line">&#x2F;*4.为什么队列的第二个值能保证j够数 </span><br><span class="line">首先每个k的第一轮无法放入这个物品，直接把k当做队首，并且这个k是用以前的状态，tail++ </span><br><span class="line">0-9塞不下10，头保留1这个继承上一规划的重量，k下一轮</span><br><span class="line">背包为11是，塞下10是可行的，11是绝对存在的 </span><br><span class="line">背包为21时，10可能只有一个，1无效但11绝对有效</span><br><span class="line">背包为31时，10可能只有一个，11无效但11绝对有效</span><br><span class="line">…… </span><br><span class="line">背包为31时，10仅有2个，1是无效的但11是有效的 </span><br><span class="line">背包为41时，10仅有3个，1是无效的但11是有效的 </span><br><span class="line">…… </span><br><span class="line"></span><br><span class="line">k-q[l]&gt;(w*All_cnt)保证了物品只有1个的情况不会填2个，那么唯一的方法就是队列下一个 </span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*5.head和tail怎么操作 </span><br><span class="line"></span><br><span class="line">q[head]并没有记录选取了多少当前个，而是记录了选当前物品的情况下，要用上一轮哪一个背包格子 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	int w,v,cnt;</span><br><span class="line">    	scanf(&quot;%d%d%d&quot;,&amp;w,&amp;v,&amp;cnt);&#x2F;&#x2F;w是重量，v是价值 ,cnt是个数 </span><br><span class="line">    	memcpy(f,g,sizeof(g));&#x2F;&#x2F;上一轮的状态转移 </span><br><span class="line">    	for(int mod&#x3D;0;mod&lt;w;mod++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		int l&#x3D;0,r&#x3D;-1;</span><br><span class="line">    		for(int k&#x3D;mod;k&lt;&#x3D;m;k+&#x3D;w)</span><br><span class="line">    		&#123;</span><br><span class="line">    			if(l&lt;&#x3D;r and k-q[l]&gt;(cnt*w))l++;</span><br><span class="line">    			if(l&lt;&#x3D;r)g[k]&#x3D;max(f[q[l]]+(k-q[l])&#x2F;w*v,g[k]);</span><br><span class="line">    			&#x2F;&#x2F;dp[mod+3w] &#x3D; max(dp[mod], dp[mod+w] - v, dp[mod+2w] - 2v, dp[mod+3w] - 3v) + 3v</span><br><span class="line">    			while(l&lt;&#x3D;r and f[q[r]]-(q[r]-mod)&#x2F;w*v&lt;&#x3D;f[k]-(k-mod)&#x2F;w*v)r--;</span><br><span class="line">				&#x2F;&#x2F;等号重要，61格价值1，取代11格价值1 ，需要填的数量少了，可以填的多了 </span><br><span class="line">    			&#x2F;&#x2F;队尾没有当前物品和k背包没有当前物品，队尾失去意义 </span><br><span class="line">    			&#x2F;&#x2F;公式是统一减去那一格已经选好的物品，再直接填满 </span><br><span class="line">    			&#x2F;&#x2F;q[r]&#x3D;mod+x*w    则减去的价值&#x3D;(q[r]-mod)&#x2F;w*v </span><br><span class="line">    			&#x2F;&#x2F;dp[mod+3w] &#x3D; max(dp[mod], dp[mod+w] - v, dp[mod+2w] - 2v, dp[mod+3w] - 3v) + 3v</span><br><span class="line">    			&#x2F;&#x2F;dp[mod+3w] &#x3D; max(dp[mod]+ 3v, dp[mod+w] + 2v, dp[mod+2w] + v, dp[mod+3w]) </span><br><span class="line">    			&#x2F;&#x2F;你要保证你在这个队列所有的可选选项是一致的，这样 填充才会一样 </span><br><span class="line">				q[++r]&#x3D;k;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;g[m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
</details>

<details>
<summary>(深度：4)简单</summary>
原方法：    f[j]=max(f[j], f[j-w]+v);  

<p>二进制背包：由于一个数x，可以由若干位的二进制组成，这些二进制数1248只有唯一一个，5位二进制可以代表0-31<br>    也可以将一个数分解成一个全是1的二进制+一个值，例如35=11111+4，压入6个就可以<br>    对于选择&lt;=x的任一一个数，这样的选取有效  </p>
<p>队列：<br>    三要点：<br>    1.    if(l&lt;=r and k-q[l]&gt;v*cnt)l++;    //填充法则保证必能填满<br>    2.    if(l&lt;=r)g[k]=max(g[k],f[q[l]]+(k-q[l])/v*w);<br>        //dp[j+3v] = max(dp[j] + 3w,  dp[j+v] + 2w, dp[j+2v] + w, dp[j+3v])<br>        //找最大值记录的是体积<br>    3.    while(l&lt;=r and f[q[r]]-(q[r]-j)/v*w&lt;=f[k]-(k-j)/v*w)r–;<br>        //dp[j+3v] = max(dp[j], dp[j+v] - w, dp[j+2v] - 2w, dp[j+3v] - 3w) + 3w<br>        //保证队列单调性<br>多维：一样是线性关系<br>    for(int j=v;j&gt;=V;j–)<br>    {<br>        for(int k=m;k&gt;=M;k–)<br>        {<br>            f[j][k]=max(f[j-V][k-M]+w,f[j][k]);<br>        }<br>    }<br>分组：<br>    对那一个组的物品同时dp一个j位置的物品  </p>
</details>
</details>
</details>

<details>
<summary>(深度：2)数据结构</summary>

<details>
<summary>(深度：3)其他</summary>
交换  
void p_clear()  
{  
    priority_queue<qii,vector<qii>,greater<qii> >empty;  
    swap(p,empty);  
}  
</details>

<details>
<summary>(深度：3)单调队列</summary>
</details>
</details>

<details>
<summary>(深度：2)模拟</summary>

<details>
<summary>(深度：3)旋转正方形某一层</summary>
假如这个是第x层，那么就应该从(x,x)开始，右上角(x,n-x+1),右下角(n-x+1,n-x+1),左下角(n-x+1,x)  
如果是右旋（顺时针），左上a[x][i], 右上a[i][n-x+1]，右下a[n-x+1][n-i+1]，左下a[n-i+1][x]，左上等于左下  
如果是左旋, 左上等于右上，并且要注意初始时记录一层。ixxiixxi, n-x+1, x-i+1  
void clockwise(int x)//假如这个是一个n*n正方形  
{//exch：当字符移开原地时进行的操作  
    if(x==n-x+1)//最里面的那一层  
    {  
        a[x][x]=exch(a[x][x]);  
        return;  
    }  
    char t[maxn];  
    for(int i=x;i<=n-x+1;i++)t[i]=a[i][x];//左层保留   
    for(int i=x;i<n-x+1;i++)  
    {  
        a[n-i+1][x]=exch(a[n-x+1][n-i+1]);//左下，右下   
        a[n-x+1][n-i+1]=exch(a[i][n-x+1]);//右下，右上   
        a[i][n-x+1]=exch(a[x][i]);//右上，左上   
        a[x][i]=exch(t[n-i+1]);//左上，左下   
    }   
}  
</details>

<details>
<summary>(深度：3)火柴棒个数</summary>
//"999911111","999971111","999977711","999991111"……  
//"999999971","999999977","999999974","999999991","999999997","999999994","999999995","999999999"  
        if(k<n*2 or n*7<k)  
        {  
            printf("-1\n");  
            continue;  
        }  
        if(n*6<=k and k<=n*7)  
        {  
            for(int i=1;i<=n*7-k;i++)printf("9");  
            for(int j=1;j<=n-(n*7-k);j++)printf("8");  
            printf("\n");  
            continue;  
        }  
    while(num_9--)printf("9");  
    while(num_7--)printf("7");  
    while(num_4--)printf("4");  
    while(num_1--)printf("1");  
    while(num_5--)printf("5");  
</details>
</details>

<details>
<summary>(深度：2)重定向</summary>
void redirect_fout(string s)  
{  
    kout.close();  
    if(s.empty())return;  
    kout.open(&s[0]);  
}  
void redirect_Fin(string s)  
{  
    FILE *fin;  
    fin=fopen("123.txt","r");  
}  
freopen("test.abc","r",stdin);  
</details>
</details>
</details>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2333/05/20/utf8-ansi-acm/" data-id="ckmtydws70004s06s3d8f6fj8" data-title="acm" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/acm/" rel="tag">acm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2333/05/20/utf8-ansi-_vtuber/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          _vtuber
        
      </div>
    </a>
  
  
    <a href="/2333/05/20/utf8-ansi-c%E8%89%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">c艹</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/vtuber/" rel="tag">_vtuber</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">_日常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E8%AE%B0/" rel="tag">_日记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%92%E8%93%9D/" rel="tag">_青蓝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm/" rel="tag">acm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c%E8%89%B9/" rel="tag">c艹</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/md%E8%BD%AC%E5%8C%96%E5%99%A8/" rel="tag">md转化器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/opencv/" rel="tag">opencv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E4%B9%A6/" rel="tag">设计书</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/vtuber/" style="font-size: 10px;">_vtuber</a> <a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 10px;">_日常</a> <a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size: 10px;">_日记</a> <a href="/tags/%E9%9D%92%E8%93%9D/" style="font-size: 10px;">_青蓝</a> <a href="/tags/acm/" style="font-size: 10px;">acm</a> <a href="/tags/c%E8%89%B9/" style="font-size: 10px;">c艹</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/md%E8%BD%AC%E5%8C%96%E5%99%A8/" style="font-size: 10px;">md转化器</a> <a href="/tags/opencv/" style="font-size: 10px;">opencv</a> <a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">游戏</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E4%B9%A6/" style="font-size: 10px;">设计书</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2333/05/">五月 2333</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2333/05/20/utf8-ansi-_%E6%97%A5%E5%B8%B8/">_日常</a>
          </li>
        
          <li>
            <a href="/2333/05/20/utf8-ansi-_%E6%97%A5%E8%AE%B0/">_日记</a>
          </li>
        
          <li>
            <a href="/2333/05/20/utf8-ansi-_vtuber/">_vtuber</a>
          </li>
        
          <li>
            <a href="/2333/05/20/utf8-ansi-acm/">acm</a>
          </li>
        
          <li>
            <a href="/2333/05/20/utf8-ansi-c%E8%89%B9/">c艹</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 beikuzi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":140,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>